<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Auth - NoDom Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #007aff;
        --primary-hover: #0056cc;
        --secondary-color: #5856d6;
        --success-color: #34c759;
        --warning-color: #ff9500;
        --warning-hover: #e6850e;
        --error-color: #ff3b30;
        --background: #f2f2f7;
        --surface: #ffffff;
        --surface-secondary: #f9f9fb;
        --text-primary: #1d1d1f;
        --text-secondary: #86868b;
        --text-tertiary: #c7c7cc;
        --border-color: #e5e5ea;
        --border-focus: #007aff;
        --shadow-light: 0 1px 3px rgba(0, 0, 0, 0.1);
        --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.15);
        --shadow-heavy: 0 8px 25px rgba(0, 0, 0, 0.15);
        --radius-small: 8px;
        --radius-medium: 12px;
        --radius-large: 16px;
        --spacing-xs: 4px;
        --spacing-sm: 8px;
        --spacing-md: 16px;
        --spacing-lg: 24px;
        --spacing-xl: 32px;
        --spacing-2xl: 48px;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background: var(--background);
        color: var(--text-primary);
        line-height: 1.6;
        font-size: 16px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--spacing-lg);
        min-height: 100vh;
      }

      .app-header {
        text-align: center;
        margin-bottom: var(--spacing-2xl);
        padding: var(--spacing-xl) 0;
      }

      .app-title {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: var(--spacing-sm);
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .app-subtitle {
        font-size: 1.1rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .main-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: var(--spacing-xl);
        margin-bottom: var(--spacing-2xl);
      }

      .action-group {
        background: var(--surface);
        border-radius: var(--radius-large);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }

      .action-group:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-heavy);
      }

      .action-group h2 {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }

      .action-group h3 {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--spacing-md);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .status-badge {
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .status-supported {
        background: rgba(52, 199, 89, 0.1);
        color: var(--success-color);
      }

      .status-not-supported {
        background: rgba(255, 59, 48, 0.1);
        color: var(--error-color);
      }

      .status-warning {
        background: rgba(255, 149, 0, 0.1);
        color: var(--warning-color);
      }

      .form-group {
        margin-bottom: var(--spacing-md);
      }

      .form-group input,
      .form-group select {
        width: 100%;
        padding: var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-small);
        font-size: 1rem;
        font-family: inherit;
        background: var(--surface);
        color: var(--text-primary);
        transition: all 0.2s ease;
      }

      .form-group input:focus,
      .form-group select:focus {
        outline: none;
        border-color: var(--border-focus);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
      }

      .form-group input::placeholder {
        color: var(--text-tertiary);
      }

      .primary-button,
      .action-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-small);
        font-size: 0.95rem;
        font-weight: 500;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        min-height: 44px;
        margin: var(--spacing-xs);
      }

      .primary-button {
        background: var(--primary-color);
        color: white;
      }

      .primary-button:hover:not(:disabled) {
        background: var(--primary-hover);
        transform: translateY(-1px);
      }

      .action-button {
        background: var(--surface);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .action-button:hover:not(:disabled) {
        background: var(--surface-secondary);
        border-color: var(--border-focus);
        transform: translateY(-1px);
      }

      .warning-button {
        background: var(--warning-color);
        color: white;
      }

      .warning-button:hover:not(:disabled) {
        background: var(--warning-hover);
        transform: translateY(-1px);
      }

      .primary-button:disabled,
      .action-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
      }

      .form-actions {
        display: flex;
        gap: var(--spacing-sm);
        flex-wrap: wrap;
        margin-top: var(--spacing-md);
      }

      .form-actions button {
        flex: 1;
        min-width: 120px;
      }

      .user-id {
        background: var(--surface-secondary);
        padding: var(--spacing-md);
        border-radius: var(--radius-small);
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        word-break: break-all;
        margin-bottom: var(--spacing-md);
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      .user-id.empty {
        color: var(--text-tertiary);
        font-style: italic;
        background: var(--background);
      }

      .user-status-display {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-md);
        border: 1px solid var(--border-color);
        margin-top: var(--spacing-md);
        overflow: hidden;
      }

      .status-row {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
        flex-wrap: wrap;
      }

      .status-row:last-child {
        margin-bottom: 0;
      }

      .status-indicator {
        font-weight: 500;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-small);
        font-size: 0.9rem;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .status-indicator.status-success {
        background: rgba(52, 199, 89, 0.1);
        color: var(--success-color);
        border: 1px solid var(--success-color);
      }

      .status-indicator.status-warning {
        background: rgba(255, 149, 0, 0.1);
        color: var(--warning-color);
        border: 1px solid var(--warning-color);
      }

      .status-indicator.status-error {
        background: rgba(255, 59, 48, 0.1);
        color: var(--error-color);
        border: 1px solid var(--error-color);
      }

      .user-info {
        background: var(--surface);
        border-radius: var(--radius-small);
        padding: var(--spacing-sm);
        font-size: 0.9rem;
        line-height: 1.4;
        word-break: break-all;
        overflow-wrap: break-word;
        max-width: 100%;
        margin-top: var(--spacing-sm);
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        border: 1px solid var(--border-color);
      }

      #results {
        background: var(--surface);
        border-radius: var(--radius-large);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
        min-height: 200px;
        margin-top: var(--spacing-xl);
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        color: var(--text-primary);
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 400px;
        overflow-y: auto;
        background: var(--surface-secondary);
      }

      .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid transparent;
        border-top: 2px solid currentColor;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .fade-in {
        animation: fadeInUp 0.6s ease-out;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      /* Responsive design */
      @media (max-width: 768px) {
        .container {
          padding: var(--spacing-md);
        }

        .app-title {
          font-size: 2rem;
        }

        .action-group {
          padding: var(--spacing-lg);
        }

        .form-actions {
          flex-direction: column;
        }

        .form-actions button {
          flex: none;
        }

        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Dark mode support */
      @media (prefers-color-scheme: dark) {
        :root {
          --background: #000000;
          --surface: #1c1c1e;
          --surface-secondary: #2c2c2e;
          --text-primary: #ffffff;
          --text-secondary: #8e8e93;
          --text-tertiary: #48484a;
          --border-color: #38383a;
        }
      }

      /* Custom Styles for Relay Management */
      .relay-status-card {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
      }

      .relay-status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-sm);
      }

      .peer-count-badge {
        background: var(--success-color);
        color: white;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        min-width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .current-peers-display {
        overflow-y: auto;
        max-height: 150px;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-small);
        background: var(--surface);
        padding: var(--spacing-sm);
      }

      .peers-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
      }

      .no-peers-message {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: var(--spacing-lg);
        color: var(--text-tertiary);
        font-style: italic;
        text-align: center;
      }

      .add-peer-section {
        margin-top: var(--spacing-lg);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
      }

      .add-peer-section h4 {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: var(--spacing-md);
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }

      .relay-examples {
        margin-top: var(--spacing-sm);
      }

      .relay-examples-details {
        cursor: pointer;
        background: var(--surface);
        border-radius: var(--radius-small);
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }

      .relay-examples-content {
        padding-left: var(--spacing-md);
      }

      .relay-example {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-xs) 0;
        cursor: pointer;
      }

      .relay-example:hover {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-xs);
      }

      .example-label {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .warning-button {
        background: var(--warning-color);
        color: white;
      }

      .warning-button:hover:not(:disabled) {
        background: var(--warning-hover);
        transform: translateY(-1px);
      }

      /* Peer List Items */
      .peer-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-xs);
        border-radius: var(--radius-small);
        border: 1px solid var(--border-color);
        transition: all 0.2s ease;
      }

      .peer-item:hover {
        background: var(--surface);
        transform: translateX(4px);
      }

      .peer-connected {
        border-left: 4px solid var(--success-color);
        background: rgba(52, 199, 89, 0.05);
      }

      .peer-disconnected {
        border-left: 4px solid var(--error-color);
        background: rgba(255, 59, 48, 0.05);
      }

      .peer-status {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
      }

      .peer-status-icon {
        font-size: 0.8rem;
      }

      .peer-status-text {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .peer-url {
        font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      /* Responsive improvements for relay management */
      @media (max-width: 768px) {
        .peer-item {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-xs);
        }

        .relay-examples-content {
          padding-left: 0;
        }

        .form-actions {
          flex-direction: column;
        }

        .form-actions button {
          width: 100%;
          margin: var(--spacing-xs) 0;
        }

        .status-row {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-xs);
        }

        .status-indicator {
          width: 100%;
          text-align: center;
          white-space: normal;
          word-break: break-word;
        }

        .user-id {
          font-size: 0.8rem;
          padding: var(--spacing-sm);
        }

        .user-info {
          font-size: 0.8rem;
          padding: var(--spacing-sm);
          line-height: 1.3;
        }

        .relay-status-header {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-sm);
        }

        .main-grid {
          grid-template-columns: 1fr;
          gap: var(--spacing-lg);
        }

        .user-status-display {
          padding: var(--spacing-sm);
        }

        .action-group {
          padding: var(--spacing-md);
        }
      }

      /* Improved animations */
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .fade-in {
        animation: fadeInUp 0.6s ease-out;
      }

      /* Improved button states */
      .primary-button:disabled,
      .action-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none;
      }

      .primary-button:hover:not(:disabled),
      .action-button:hover:not(:disabled) {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      /* Better focus states */
      .form-group input:focus,
      .form-group select:focus {
        outline: none;
        border-color: var(--border-focus);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        transform: translateY(-1px);
      }
    </style>
  </head>

  <body>
    <div id="app"></div>

    <!-- Include libraries -->
    <script src="https://cdn.jsdelivr.net/npm/gun/dist/gun.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/dist/lib/wire.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shogun-core/dist/browser/shogun-core.js"></script>
    <script type="module">
      // Import NoDom functions
      import {
        init,
        setSignal,
        setEffect,
        setMemo,
        h,
        Fragment,
        auth as nodomAuth,
        logout as nodomLogout,
        getNamespace,
        setNamespace,
      } from "./libs/nodom.js";

      // Global state signals
      let shogun;
      let gun;

      // Reactive state
      const [getInitialized, setInitialized] = setSignal(false, {
        key: "app.initialized",
      });
      const [getAuthStatus, setAuthStatus] = setSignal("‚ùå Not authenticated", {
        key: "app.authStatus",
      });
      const [getUserInfo, setUserInfo] = setSignal("", { key: "app.userInfo" });
      const [getResults, setResults] = setSignal(
        "Results will appear here...",
        { key: "app.results" }
      );
      const [getLoading, setLoading] = setSignal(false, { key: "app.loading" });

      // Plugin status signals
      const [getWebAuthnStatus, setWebAuthnStatus] = setSignal(
        "NON INIZIALIZZATO",
        { key: "plugins.webauthn" }
      );
      const [getEthereumStatus, setEthereumStatus] = setSignal(
        "NON INIZIALIZZATO",
        { key: "plugins.web3" }
      );
      const [getBitcoinStatus, setBitcoinStatus] = setSignal(
        "NON INIZIALIZZATO",
        { key: "plugins.nostr" }
      );

      // Form data signals
      const [getUsername, setUsername] = setSignal("", {
        key: "forms.username",
      });
      const [getPassword, setPassword] = setSignal("", {
        key: "forms.password",
      });
      const [getWebAuthnUsername, setWebAuthnUsername] = setSignal("", {
        key: "forms.webauthn.username",
      });

      // Wallet state signals
      const [getMetamaskAddress, setMetamaskAddress] = setSignal(
        "No wallet connected",
        { key: "wallets.metamask.address" }
      );
      const [getNostrAddress, setNostrAddress] = setSignal(
        "No wallet connected",
        { key: "wallets.nostr.address" }
      );

      // Relay management signals
      const [getPeerCount, setPeerCount] = setSignal(0, {
        key: "relay.peerCount",
      });
      const [getPeersList, setPeersList] = setSignal("No peers configured", {
        key: "relay.peersList",
      });
      const [getNewPeerUrl, setNewPeerUrl] = setSignal("", {
        key: "relay.newPeerUrl",
      });

      // Plugin
      let webauthnPlugin;
      let ethereumPlugin;
      let bitcoinPlugin;
      // Note: BIP44 plugin is now external - install @shogun/bip44 package separately
      // let bip44Plugin;

      // Utility functions
      function showResult(title, data) {
        const resultText = `${title}\n\n${JSON.stringify(data, null, 2)}`;
        setResults(resultText);
      }

      function showError(title, error) {
        const errorText = `${title} - ERRORE\n\n${error.message || error}`;
        setResults(errorText);
        console.error(error);
      }

      function setButtonLoading(isLoading) {
        setLoading(isLoading);
      }

      // Helper functions to extract clean addresses
      function extractAddress(addressString) {
        if (!addressString || addressString === "No wallet connected") {
          return null;
        }

        // If it starts with "Indirizzo: ", extract the actual address
        if (addressString.startsWith("Indirizzo: ")) {
          return addressString.replace("Indirizzo: ", "").trim();
        }

        // Otherwise return as is
        return addressString.trim();
      }

      function getCleanEthereumAddress() {
        return extractAddress(getMetamaskAddress());
      }

      function getCleanBitcoinAddress() {
        return extractAddress(getNostrAddress());
      }

      // Check support functions
      function checkWebAuthnSupport() {
        if (!webauthnPlugin) {
          setWebAuthnStatus("NON INIZIALIZZATO");
          return false;
        }

        try {
          // Check browser support for WebAuthn
          const browserSupported =
            typeof window.PublicKeyCredential !== "undefined";

          // Check plugin support
          const pluginSupported = webauthnPlugin.isSupported();

          const isSupported = browserSupported && pluginSupported;

          if (isSupported) {
            setWebAuthnStatus("SUPPORTATO");
          } else if (browserSupported && !pluginSupported) {
            setWebAuthnStatus("PLUGIN ERROR");
          } else {
            setWebAuthnStatus("NON SUPPORTATO");
          }

          return isSupported;
        } catch (error) {
          console.error(
            "Errore durante il controllo del supporto WebAuthn:",
            error
          );
          setWebAuthnStatus("ERRORE");
          return false;
        }
      }

      function checkEthereumSupport() {
        if (!ethereumPlugin) {
          setEthereumStatus("NON INIZIALIZZATO");
          return false;
        }

        try {
          const isAvailable = typeof window.ethereum !== "undefined";
          setEthereumStatus(isAvailable ? "RILEVATO" : "NON RILEVATO");
          return isAvailable;
        } catch (error) {
          console.error(
            "Errore durante il controllo del supporto Ethereum:",
            error
          );
          setEthereumStatus("ERRORE");
          return false;
        }
      }

      function checkBitcoinSupport() {
        if (!bitcoinPlugin) {
          setBitcoinStatus("NON INIZIALIZZATO");
          return false;
        }

        try {
          const nostrAvailable = typeof window.nostr !== "undefined";
          let pluginNostrAvailable = false;
          if (typeof bitcoinPlugin.isNostrExtensionAvailable === "function") {
            pluginNostrAvailable = bitcoinPlugin.isNostrExtensionAvailable();
          }

          const isAvailable = nostrAvailable || pluginNostrAvailable || true;
          const supportText = isAvailable
            ? nostrAvailable || pluginNostrAvailable
              ? "Nostr"
              : "Manuale"
            : "NON DISPONIBILE";

          setBitcoinStatus(supportText);
          return isAvailable;
        } catch (error) {
          console.error(
            "Errore durante il controllo del supporto Bitcoin:",
            error
          );
          setBitcoinStatus("ERRORE");
          return false;
        }
      }

      function updateAuthenticationStatus() {
        if (!shogun) {
          setAuthStatus("‚ùå Not authenticated");
          setUserInfo("");
          return;
        }

        const isLoggedIn = shogun.isLoggedIn();
        const authMethod =
          typeof shogun.getAuthMethod === "function"
            ? shogun.getAuthMethod()
            : null;

        const hasSessionData =
          sessionStorage.getItem("gun/") ||
          sessionStorage.getItem("gun/user") ||
          sessionStorage.getItem("gun/auth");

        if (isLoggedIn) {
          let statusText = "‚úÖ Authenticated";
          if (authMethod) {
            statusText += ` (${authMethod})`;
          }
          setAuthStatus(statusText);

          const user = shogun.gun.user();
          if (user && user.is && user.is.alias) {
            // Format user info with proper line breaks and structure
            const userInfoText = `User: ${user.is.alias}\n\nPublic Key:\n${user.is.pub}`;
            setUserInfo(userInfoText);
          } else {
            setUserInfo("");
          }
        } else if (hasSessionData) {
          setAuthStatus("üîÑ Session Active (checking...)");
          setUserInfo("");
        } else {
          setAuthStatus("‚ùå Not authenticated");
          setUserInfo("");
        }
      }

      // Authentication handlers
      async function handleInitialize() {
        try {
          console.log("üöÄ Starting Shogun initialization...");
          setButtonLoading(true);

          // Check if required dependencies are available
          if (typeof Gun === "undefined") {
            console.error("‚ùå Gun.js not loaded");
            throw new Error("Gun.js not loaded. Please check the script tags.");
          }

          if (typeof window.initShogunBrowser === "undefined") {
            console.error("‚ùå Shogun Core not loaded");
            throw new Error(
              "Shogun Core not loaded. Please check the script tags."
            );
          }

          console.log("‚úÖ Dependencies check passed");

          let peer = "http://localhost:8765/gun";

          const options = {
            peers: [peer],
            localStorage: false,
            radisk: false,
          };

          const config = {
            gunInstance: new Gun(options),
            // scope: "shogun",
            peers: [peer],
            webauthn: {
              enabled: true,
              rpName: "Shogun Demo",
              rpId: window.location.hostname,
            },
            web3: {
              enabled: true,
            },
            nostr: {
              enabled: true,
              network: "mainnet",
              defaultWalletType: "nostr",
            },
            logging: {
              enabled: true,
              level: "debug",
              prefix: "[Shogun Demo]",
            },
          };

          showResult("Inizializzazione", {
            message: "Inizializzazione in corso...",
            status: "processing",
          });

          console.log("üîß Creating Shogun instance...");
          try {
            shogun = window.initShogunBrowser(config);
            console.log("‚úÖ Shogun instance created");
          } catch (shogunError) {
            console.error("‚ùå Error creating Shogun instance:", shogunError);
            throw new Error(
              `Failed to create Shogun instance: ${shogunError.message}`
            );
          }

          gun = shogun.gun;

          console.log("üîó Initializing NoDom with Gun instance...");
          try {
            // Initialize NoDom with Gun instance
            init(gun);
            console.log("‚úÖ NoDom initialized");
          } catch (nodomError) {
            console.error("‚ùå Error initializing NoDom:", nodomError);
            throw new Error(
              `Failed to initialize NoDom: ${nodomError.message}`
            );
          }

          try {
            // Enhanced token injection for both Shogun and Gun instances
            const attachTokenHandlers = (gunInstance, label) => {
              gunInstance.on("out", function (msg) {
                var to = this.to;
                
                // Always ensure headers exist
                if (!msg.headers) msg.headers = {};
                
                // Set token in multiple locations for compatibility
                msg.headers.token = "shogun2025";
                msg.token = "shogun2025";
                msg.headers.Authorization = "Bearer shogun2025";
                
                console.log(`üì§ ${label} - Token attached to outgoing message:`, {
                  type: msg.put ? 'PUT' : msg.get ? 'GET' : 'OTHER',
                  hasToken: !!msg.token,
                  isUserAuth: msg.put && Object.keys(msg.put).some(key => key.startsWith('~@'))
                });
                
                to.next(msg);
              });
            };

            // Attach handlers to both instances
            attachTokenHandlers(shogun.gun, "Shogun");
            attachTokenHandlers(gun, "Window");

            console.log("‚úÖ Enhanced Gun event handlers attached");
          } catch (gunError) {
            console.warn(
              "‚ö†Ô∏è Warning: Could not attach Gun event handlers:",
              gunError
            );
            // Non-fatal error, continue
          }

          // Get plugin references
          try {
            webauthnPlugin = shogun.getPlugin("webauthn");
            bitcoinPlugin = shogun.getPlugin("nostr");
            // Note: BIP44 plugin is now external - install @shogun/bip44 package separately
            // bip44Plugin = shogun.getPlugin("bip44");
            ethereumPlugin = shogun.getPlugin("web3");
            console.log("‚úÖ Plugin references obtained");
          } catch (pluginError) {
            console.warn(
              "‚ö†Ô∏è Warning: Could not get all plugin references:",
              pluginError
            );
            // Non-fatal error, continue
          }

          // Check support - declare variables outside try block
          let webauthnSupported = false;
          let ethereumSupported = false;
          let bitcoinSupported = false;

          try {
            webauthnSupported = checkWebAuthnSupport();
            ethereumSupported = checkEthereumSupport();
            bitcoinSupported = checkBitcoinSupport();
            console.log("‚úÖ Support checks completed");
          } catch (supportError) {
            console.warn(
              "‚ö†Ô∏è Warning: Error during support checks:",
              supportError
            );
            // Non-fatal error, continue - variables remain false
          }

          window.shogun = shogun;
          console.log("‚úÖ Shogun initialized and exposed globally");

          setInitialized(true);
          updateAuthenticationStatus();

          showResult("Shogun Inizializzato", {
            stato: "Successo",
            connesso: true,
            webauthn: webauthnSupported || false,
            web3: ethereumSupported || false,
            nostr: bitcoinSupported || false,
            plugins: {
              webauthn: !!webauthnPlugin,
              web3: !!ethereumPlugin,
              nostr: !!bitcoinPlugin,
              // Note: BIP44 plugin is now external - install @shogun/bip44 package separately
              // bip44: !!bip44Plugin,
            },
            timestamp: new Date().toISOString(),
          });

          // Update peers list after initialization
          setTimeout(() => {
            updatePeersList();
          }, 500);

          console.log("üéâ Shogun initialization completed successfully");
        } catch (error) {
          console.error("üí• Fatal error in handleInitialize:", error);
          showError("Inizializzazione", error);
          // Ensure loading state is reset even on error
          setButtonLoading(false);
          throw error; // Re-throw to be caught by button handler
        } finally {
          setButtonLoading(false);
          console.log("üîÑ handleInitialize finally block executed");
        }
      }

      // Wallet connection handlers
      async function handleConnectEthereum() {
        try {
          if (!ethereumPlugin) {
            showError("MetaMask", new Error("Plugin Ethereum non disponibile"));
            return;
          }

          setButtonLoading(true);
          showResult("MetaMask", { message: "Connessione in corso..." });

          const result = await ethereumPlugin.connectMetaMask();

          if (result.success) {
            setMetamaskAddress(`Indirizzo: ${result.address}`);
            showResult("MetaMask Connesso", result);
          } else {
            showError(
              "MetaMask",
              new Error(result.error || "Errore durante la connessione")
            );
          }
        } catch (error) {
          showError("MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleConnectBitcoin() {
        try {
          if (!bitcoinPlugin) {
            showError(
              "Bitcoin Wallet",
              new Error("Plugin Bitcoin non disponibile")
            );
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", { message: "Connessione in corso..." });

          const result = await bitcoinPlugin.connectBitcoinWallet("nostr");

          if (result.success) {
            setNostrAddress(`Indirizzo: ${result.address}`);
            showResult("Bitcoin Wallet Connesso", result);
          } else {
            showError(
              "Bitcoin Wallet",
              new Error(result.error || "Errore durante la connessione")
            );
          }
        } catch (error) {
          showError("Bitcoin Wallet", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Ethereum login/signup handlers
      async function handleEthereumLogin() {
        try {
          if (!ethereumPlugin) {
            showError(
              "Login MetaMask",
              new Error("Plugin Ethereum non disponibile")
            );
            return;
          }

          setButtonLoading(true);

          // Connect first if not connected
          let currentAddress = getCleanEthereumAddress();
          if (!currentAddress) {
            const connectResult = await ethereumPlugin.connectMetaMask();
            if (!connectResult.success) {
              showError(
                "Connessione MetaMask",
                new Error(
                  connectResult.error || "Errore durante la connessione"
                )
              );
              return;
            }
            setMetamaskAddress(`Indirizzo: ${connectResult.address}`);
            currentAddress = connectResult.address;
          }

          showResult("MetaMask", { message: "Login in corso..." });

          const result = (await ethereumPlugin.login)
            ? await ethereumPlugin.login(currentAddress)
            : await ethereumPlugin.loginWithMetaMask(currentAddress);

          if (result.success) {
            showResult("Login con MetaMask completato", result);
            updateAuthenticationStatus();
          } else {
            showError(
              "Login MetaMask",
              new Error(result.error || "Errore durante il login")
            );
          }
        } catch (error) {
          showError("Login MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleEthereumSignup() {
        try {
          if (!ethereumPlugin) {
            showError(
              "Registrazione MetaMask",
              new Error("Plugin Ethereum non disponibile")
            );
            return;
          }

          setButtonLoading(true);

          // Connect first if not connected
          let currentAddress = getCleanEthereumAddress();
          if (!currentAddress) {
            const connectResult = await ethereumPlugin.connectMetaMask();
            if (!connectResult.success) {
              showError(
                "Connessione MetaMask",
                new Error(
                  connectResult.error || "Errore durante la connessione"
                )
              );
              return;
            }
            setMetamaskAddress(`Indirizzo: ${connectResult.address}`);
            currentAddress = connectResult.address;
          }

          showResult("MetaMask", { message: "Registrazione in corso..." });

          const result = (await ethereumPlugin.signUp)
            ? await ethereumPlugin.signUp(currentAddress)
            : await ethereumPlugin.signUpWithMetaMask(currentAddress);

          if (result.success) {
            showResult("Registrazione con MetaMask completata", result);
            updateAuthenticationStatus();
          } else {
            showError(
              "Registrazione MetaMask",
              new Error(result.error || "Errore durante la registrazione")
            );
          }
        } catch (error) {
          showError("Registrazione MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Bitcoin login/signup handlers
      async function handleBitcoinLogin() {
        try {
          if (!bitcoinPlugin) {
            showError(
              "Login Bitcoin",
              new Error("Plugin Bitcoin non disponibile")
            );
            return;
          }

          const currentAddress = getCleanBitcoinAddress();
          if (!currentAddress) {
            showError(
              "Login Bitcoin",
              new Error(
                "Nessun indirizzo Bitcoin configurato. Clicca prima su 'Connect Wallet'."
              )
            );
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", { message: "Login in corso..." });

          const alias =
            localStorage.getItem("bitcoin_user_alias") ||
            `btc_user_fallback_${currentAddress.substring(0, 6)}`;
          const options = {
            walletType: "nostr",
            alias,
            forceConnect: true,
            debug: true,
          };

          console.log("üîç Bitcoin login debug:", {
            currentAddress,
            addressLength: currentAddress.length,
            alias,
            options,
          });

          const result = await bitcoinPlugin.login(currentAddress, options);

          if (result.success) {
            showResult("Login con Bitcoin completato", result);
            updateAuthenticationStatus();
          } else {
            showError(
              "Login Bitcoin",
              new Error(result.error || "Login fallito")
            );
          }
        } catch (error) {
          showError("Login Bitcoin", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleBitcoinSignup() {
        try {
          if (!bitcoinPlugin) {
            showError(
              "Registrazione Bitcoin",
              new Error("Plugin Bitcoin non disponibile")
            );
            return;
          }

          const currentAddress = getCleanBitcoinAddress();
          if (!currentAddress) {
            showError(
              "Registrazione Bitcoin",
              new Error(
                "Nessun indirizzo Bitcoin configurato. Clicca prima su 'Connect Wallet'."
              )
            );
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", {
            message: "Registrazione in corso...",
          });

          const alias = `btc_user_${Date.now().toString(
            36
          )}_${currentAddress.substring(0, 6)}`;
          const options = { walletType: "nostr", alias, forceCreate: true };

          console.log("üîç Bitcoin signup debug:", {
            currentAddress,
            addressLength: currentAddress.length,
            alias,
            options,
          });

          const result = await bitcoinPlugin.signUp(currentAddress, options);

          if (result.success) {
            localStorage.setItem("bitcoin_user_alias", alias);
            showResult("Registrazione con Bitcoin completata", result);
            updateAuthenticationStatus();
          } else {
            if (
              result.error &&
              (result.error.includes("already created") ||
                result.error.includes("gi√† creato") ||
                result.error.includes("already exists"))
            ) {
              localStorage.setItem("bitcoin_user_alias", alias);
              showResult("Account gi√† esistente", {
                success: true,
                message: "L'utente esiste gi√†. Prova a effettuare il login.",
                alias: alias,
                suggestion:
                  "Clicca sul pulsante 'Login con Bitcoin' per accedere.",
              });
              updateAuthenticationStatus();
            } else {
              showError(
                "Registrazione Bitcoin",
                new Error(result.error || "Registrazione fallita")
              );
            }
          }
        } catch (error) {
          showError("Registrazione Bitcoin", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Relay management functions
      function updatePeersList() {
        if (!shogun || !shogun.gundb) {
          setPeersList("Shogun not initialized");
          setPeerCount(0);
          return;
        }

        try {
          const peerInfo = shogun.gundb.getPeerInfo();
          const peerEntries = Object.entries(peerInfo);
          const connectedCount = peerEntries.filter(
            ([_, info]) => info.connected
          ).length;

          setPeerCount(peerEntries.length);

          if (peerEntries.length === 0) {
            setPeersList("No peers configured");
            return;
          }

          // Create peer list HTML
          const peerListHtml = peerEntries
            .map(([peer, info]) => {
              const statusIcon = info.connected ? "üü¢" : "üî¥";
              const statusText = info.connected ? "Connected" : "Disconnected";

              return `
              <div class="peer-item ${
                info.connected ? "peer-connected" : "peer-disconnected"
              }">
                <div class="peer-status">
                  <span class="peer-status-icon">${statusIcon}</span>
                  <span class="peer-status-text">${statusText}</span>
                </div>
                <div class="peer-url">
                  <code>${peer}</code>
                </div>
              </div>
            `;
            })
            .join("");

          setPeersList(peerListHtml);
        } catch (error) {
          console.error("Error updating peers list:", error);
          setPeersList("Error loading peers");
          setPeerCount(0);
        }
      }

      function fillPeerUrl(url) {
        setNewPeerUrl(url);
        showResult("Peer URL", { message: `URL impostato: ${url}` });
      }

      async function handleAddPeer() {
        if (!shogun || !shogun.gundb) {
          showError("Add Peer", new Error("Shogun not initialized"));
          return;
        }

        const peerUrl = getNewPeerUrl().trim();
        if (!peerUrl) {
          showError("Add Peer", new Error("Please enter a peer URL"));
          return;
        }

        try {
          new URL(peerUrl);
        } catch (error) {
          showError("Add Peer", new Error("Invalid URL format"));
          return;
        }

        try {
          setButtonLoading(true);

          const existingPeers = shogun.gundb.getAllConfiguredPeers();
          if (existingPeers.includes(peerUrl)) {
            showResult("Add Peer", {
              success: false,
              message: "Peer already configured",
              peer: peerUrl,
              suggestion: "Try reconnecting to the peer instead",
            });
            return;
          }

          shogun.gundb.addPeer(peerUrl);
          setNewPeerUrl("");

          setTimeout(() => {
            updatePeersList();
            showResult("Peer Added", {
              success: true,
              peer: peerUrl,
              message: "Peer added successfully",
              timestamp: new Date().toISOString(),
            });
          }, 1000);
        } catch (error) {
          showError("Add Peer", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleRefreshPeers() {
        try {
          setButtonLoading(true);
          updatePeersList();

          showResult("Peers Refreshed", {
            success: true,
            message: "Peer list updated",
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          showError("Refresh Peers", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleClearAllPeers() {
        if (!shogun || !shogun.gundb) {
          showError("Clear Peers", new Error("Shogun not initialized"));
          return;
        }

        const confirmed = confirm(
          "‚ö†Ô∏è Attenzione!\n\n" +
            "Questa operazione rimuover√† TUTTI i peer configurati.\n" +
            "Potresti perdere la connessione alla rete Gun.js.\n\n" +
            "Sei sicuro di voler continuare?"
        );

        if (!confirmed) {
          return;
        }

        try {
          setButtonLoading(true);

          const existingPeers = shogun.gundb.getAllConfiguredPeers();
          shogun.gundb.resetPeers();
          updatePeersList();

          showResult("All Peers Cleared", {
            success: true,
            message: "All peers have been removed",
            removedPeers: existingPeers,
            warning:
              "You may need to add new peers to reconnect to the network",
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          showError("Clear Peers", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Traditional auth handlers
      async function handleLogin() {
        const username = getUsername();
        const password = getPassword();

        if (!username || !password) {
          showError("Login", new Error("Username e password sono richiesti!"));
          return;
        }

        try {
          setButtonLoading(true);

          const result = await shogun.login(username, password);

          if (result.success) {
            showResult("Login completato", result);
            updateAuthenticationStatus();
            setUsername("");
            setPassword("");
          } else {
            showError("Login", new Error(result.error || "Login fallito"));
          }
        } catch (error) {
          showError("Login", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleSignUp() {
        const username = getUsername();
        const password = getPassword();

        if (!username || !password) {
          showError(
            "Registrazione",
            new Error("Username e password sono richiesti!")
          );
          return;
        }

        try {
          setButtonLoading(true);

          const result = await shogun.signUp(username, password);

          if (result.success) {
            showResult("Registrazione completata", {
              ...result,
              message: "‚úÖ Utente registrato con successo! Login automatico completato.",
              username: username,
              timestamp: new Date().toISOString(),
            });
            updateAuthenticationStatus();
            setUsername("");
            setPassword("");
          } else {
            // Check if error indicates user already exists
            if (result.error && result.error.includes("already exists")) {
              showResult("‚ö†Ô∏è Utente Gi√† Esistente", {
                success: false,
                error: result.error,
                suggestion: "Questo username √® gi√† registrato. Prova a effettuare il login invece.",
                action: "login",
                username: username,
                timestamp: new Date().toISOString(),
              });
            } else {
              showError(
                "Registrazione",
                new Error(result.error || "Registrazione fallita")
              );
            }
          }
        } catch (error) {
          showError("Registrazione", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleLogout() {
        if (!shogun) {
          showError("Logout", new Error("Shogun non √® stato inizializzato!"));
          return;
        }

        try {
          if (!shogun.isLoggedIn()) {
            showResult("Logout", {
              success: true,
              message: "Nessun utente connesso, logout non necessario",
            });
            return;
          }

          shogun.logout();

          // Reset state
          setMetamaskAddress("No wallet connected");
          setNostrAddress("No wallet connected");
          setUsername("");
          setPassword("");
          setWebAuthnUsername("");

          // Clear localStorage
          try {
            localStorage.removeItem("bitcoin_user_alias");
            localStorage.removeItem("auth_attempt");
            localStorage.removeItem("auth_reload");
            localStorage.removeItem("is_authenticated");
            localStorage.removeItem("current_user");
          } catch (localStorageError) {
            console.warn("Could not clear localStorage:", localStorageError);
          }

          setTimeout(() => {
            checkWebAuthnSupport();
            checkEthereumSupport();
            checkBitcoinSupport();
            updateAuthenticationStatus();
          }, 100);

          showResult("Logout Completato", {
            success: true,
            message: "Disconnessione completata con successo",
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          showError("Logout", error);
        }
      }

      function clearAllStorage() {
        try {
          const localStorageKeys = [];
          const sessionStorageKeys = [];

          for (let i = 0; i < localStorage.length; i++) {
            localStorageKeys.push(localStorage.key(i));
          }

          for (let i = 0; i < sessionStorage.length; i++) {
            sessionStorageKeys.push(sessionStorage.key(i));
          }

          localStorage.clear();
          sessionStorage.clear();

          if (bitcoinPlugin) {
            try {
              bitcoinPlugin.clearSignatureCache();
            } catch (bitcoinCacheError) {
              console.warn(
                "Could not clear Bitcoin signature cache:",
                bitcoinCacheError
              );
            }
          }

          // Reset state
          setMetamaskAddress("No wallet connected");
          setNostrAddress("No wallet connected");
          setUsername("");
          setPassword("");
          setWebAuthnUsername("");

          setTimeout(() => {
            checkWebAuthnSupport();
            checkEthereumSupport();
            checkBitcoinSupport();
            updateAuthenticationStatus();
          }, 100);

          showResult("Storage Pulito", {
            success: true,
            message: "Tutti i dati di storage sono stati cancellati",
            cleared: {
              localStorage: localStorageKeys,
              sessionStorage: sessionStorageKeys,
              totalKeys: localStorageKeys.length + sessionStorageKeys.length,
            },
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          showError("Pulizia Storage", error);
        }
      }

      // WebAuthn handlers
      async function handleWebAuthnRegister() {
        const username = getWebAuthnUsername();

        if (!username) {
          showError(
            "WebAuthn Registration",
            new Error("Username √® richiesto per la registrazione WebAuthn!")
          );
          return;
        }

        if (!webauthnPlugin) {
          showError(
            "WebAuthn Registration",
            new Error("Plugin WebAuthn non disponibile")
          );
          return;
        }

        try {
          setButtonLoading(true);
          showResult("WebAuthn", { message: "Registrazione in corso..." });

          // Check WebAuthn support
          if (!webauthnPlugin.isSupported()) {
            showError(
              "WebAuthn Registration",
              new Error("WebAuthn non √® supportato in questo browser")
            );
            return;
          }

          const result = await webauthnPlugin.signUp(username);

          if (result.success) {
            showResult("Registrazione WebAuthn completata", result);
            updateAuthenticationStatus();
            setWebAuthnUsername("");
          } else {
            showError(
              "WebAuthn Registration",
              new Error(result.error || "Registrazione fallita")
            );
          }
        } catch (error) {
          showError("WebAuthn Registration", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleWebAuthnLogin() {
        const username = getWebAuthnUsername();

        if (!username) {
          showError(
            "WebAuthn Login",
            new Error("Username √® richiesto per il login WebAuthn!")
          );
          return;
        }

        if (!webauthnPlugin) {
          showError(
            "WebAuthn Login",
            new Error("Plugin WebAuthn non disponibile")
          );
          return;
        }

        try {
          setButtonLoading(true);
          showResult("WebAuthn", { message: "Login in corso..." });

          // Check WebAuthn support
          if (!webauthnPlugin.isSupported()) {
            showError(
              "WebAuthn Login",
              new Error("WebAuthn non √® supportato in questo browser")
            );
            return;
          }

          const result = await webauthnPlugin.login(username);

          if (result.success) {
            showResult("Login WebAuthn completato", result);
            updateAuthenticationStatus();
            setWebAuthnUsername("");
          } else {
            showError(
              "WebAuthn Login",
              new Error(result.error || "Login fallito")
            );
          }
        } catch (error) {
          showError("WebAuthn Login", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Component functions
      function AppHeader() {
        return h(
          "div",
          { class: "app-header" },
          h("h1", { class: "app-title" }, "ü•∑ Shogun Auth"),
          h(
            "p",
            { class: "app-subtitle" },
            "Secure authentication with reactive signals"
          )
        );
      }

      function InitializationSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h("h2", {}, "‚ö° Inizializzazione"),
          h("p", {}, "Initialize the Shogun SDK and test connections"),

          h(
            "div",
            { class: "form-actions" },
            h(
              "button",
              {
                class: () => `primary-button ${getLoading() ? "disabled" : ""}`,
                onclick: async (e) => {
                  try {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("üî¥ Initialize button clicked");
                    await handleInitialize();
                    console.log("‚úÖ Initialize completed successfully");
                  } catch (error) {
                    console.error(
                      "‚ùå Error in initialize button handler:",
                      error
                    );
                    showError("Button Handler", error);
                  } finally {
                    console.log("üîÑ Initialize button handler finished");
                  }
                  return false;
                },
                disabled: () => getLoading(),
                type: "button",
              },
              () => (getLoading() ? "Initializing..." : "Initialize Shogun")
            ),

            h(
              "button",
              {
                class: "action-button warning-button",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  clearAllStorage();
                  return false;
                },
                type: "button",
              },
              "üóëÔ∏è Clear Storage"
            )
          ),

          h(
            "div",
            { class: "user-status-display" },
            h(
              "div",
              { class: "status-row" },
              h("strong", {}, "Status: "),
              h(
                "span",
                {
                  class: () => {
                    const status = getAuthStatus();
                    if (status.includes("‚úÖ"))
                      return "status-indicator status-success";
                    if (status.includes("üîÑ"))
                      return "status-indicator status-warning";
                    return "status-indicator status-error";
                  },
                },
                () => getAuthStatus()
              )
            ),
            () =>
              getUserInfo()
                ? h(
                    "div",
                    {
                      class: "user-info",
                    },
                    () => getUserInfo()
                  )
                : null
          )
        );
      }

      function TraditionalAuthSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h("h2", {}, "üîê Username & Password"),
          h("p", {}, "Traditional authentication method"),

          h(
            "form",
            {
              onsubmit: (e) => {
                e.preventDefault();
                return false;
              },
            },
            h(
              "div",
              { class: "form-group" },
              h("input", {
                type: "text",
                placeholder: "Enter your username",
                autocomplete: "username",
                value: () => getUsername(),
                oninput: (e) => setUsername(e.target.value),
              })
            ),
            h(
              "div",
              { class: "form-group" },
              h("input", {
                type: "password",
                placeholder: "Enter your password",
                autocomplete: "current-password",
                value: () => getPassword(),
                oninput: (e) => setPassword(e.target.value),
              })
            ),
            h(
              "div",
              { class: "form-actions" },
              h(
                "button",
                {
                  class: () =>
                    `primary-button ${getLoading() ? "disabled" : ""}`,
                  onclick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleLogin();
                    return false;
                  },
                  disabled: () => getLoading(),
                  type: "button",
                },
                "Sign In"
              ),
              h(
                "button",
                {
                  class: () =>
                    `action-button ${getLoading() ? "disabled" : ""}`,
                  onclick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleSignUp();
                    return false;
                  },
                  disabled: () => getLoading(),
                  type: "button",
                },
                "Sign Up"
              ),
              h(
                "button",
                {
                  class: "action-button",
                  onclick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleLogout();
                    return false;
                  },
                  type: "button",
                },
                "Sign Out"
              )
            )
          )
        );
      }

      function WebAuthnSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h(
            "h3",
            {},
            "üîë WebAuthn",
            h(
              "span",
              {
                class: () => {
                  const status = getWebAuthnStatus();
                  if (status === "SUPPORTATO")
                    return "status-badge status-supported";
                  if (
                    status === "NON INIZIALIZZATO" ||
                    status === "PLUGIN ERROR"
                  )
                    return "status-badge status-warning";
                  return "status-badge status-not-supported";
                },
              },
              () => getWebAuthnStatus()
            )
          ),
          h("p", {}, "Biometric and hardware key authentication"),

          h(
            "form",
            {
              onsubmit: (e) => {
                e.preventDefault();
                return false;
              },
            },
            h(
              "div",
              { class: "form-group" },
              h("input", {
                type: "text",
                placeholder: "Username for WebAuthn",
                autocomplete: "username",
                value: () => getWebAuthnUsername(),
                oninput: (e) => setWebAuthnUsername(e.target.value),
              })
            ),
            h(
              "div",
              { class: "form-actions" },
              h(
                "button",
                {
                  class: () =>
                    `primary-button ${getLoading() ? "disabled" : ""}`,
                  disabled: () =>
                    getWebAuthnStatus() !== "SUPPORTATO" || getLoading(),
                  onclick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleWebAuthnLogin();
                    return false;
                  },
                  type: "button",
                },
                () => (getLoading() ? "Signing In..." : "Sign In")
              ),
              h(
                "button",
                {
                  class: () =>
                    `action-button ${getLoading() ? "disabled" : ""}`,
                  disabled: () =>
                    getWebAuthnStatus() !== "SUPPORTATO" || getLoading(),
                  onclick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleWebAuthnRegister();
                    return false;
                  },
                  type: "button",
                },
                () => (getLoading() ? "Registering..." : "Register")
              )
            )
          )
        );
      }

      function EthereumSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h(
            "h3",
            {},
            "ü¶ä Wallet Ethereum",
            h(
              "span",
              {
                class: () => {
                  const status = getEthereumStatus();
                  if (status === "RILEVATO")
                    return "status-badge status-supported";
                  if (status === "NON INIZIALIZZATO")
                    return "status-badge status-warning";
                  return "status-badge status-not-supported";
                },
              },
              () => getEthereumStatus()
            )
          ),
          h("p", {}, "Connect with MetaMask or other Ethereum wallets"),

          h(
            "div",
            {
              class: () => {
                const address = getMetamaskAddress();
                return address === "No wallet connected"
                  ? "user-id empty"
                  : "user-id";
              },
            },
            () => getMetamaskAddress()
          ),

          h(
            "div",
            { class: "form-actions" },
            h(
              "button",
              {
                class: "action-button",
                disabled: () => getEthereumStatus() !== "RILEVATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleConnectEthereum();
                  return false;
                },
                type: "button",
              },
              "Connect Wallet"
            ),
            h(
              "button",
              {
                class: "primary-button",
                disabled: () => getEthereumStatus() !== "RILEVATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleEthereumLogin();
                  return false;
                },
                type: "button",
              },
              "Sign In"
            ),
            h(
              "button",
              {
                class: "action-button",
                disabled: () => getEthereumStatus() !== "RILEVATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleEthereumSignup();
                  return false;
                },
                type: "button",
              },
              "Register"
            )
          )
        );
      }

      function BitcoinSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h(
            "h3",
            {},
            "‚Çø Bitcoin Wallet",
            h(
              "span",
              {
                class: () => {
                  const status = getBitcoinStatus();
                  if (status === "Nostr")
                    return "status-badge status-supported";
                  if (status === "NON INIZIALIZZATO")
                    return "status-badge status-warning";
                  return "status-badge status-not-supported";
                },
              },
              () => getBitcoinStatus()
            )
          ),
          h("p", {}, "Connect with Nostr extension"),

          h(
            "div",
            {
              class: () => {
                const address = getNostrAddress();
                return address === "No wallet connected"
                  ? "user-id empty"
                  : "user-id";
              },
            },
            () => getNostrAddress()
          ),

          h(
            "div",
            { class: "form-actions" },
            h(
              "button",
              {
                class: "action-button",
                disabled: () => getBitcoinStatus() === "NON INIZIALIZZATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleConnectBitcoin();
                  return false;
                },
                type: "button",
              },
              "Connect Wallet"
            ),
            h(
              "button",
              {
                class: "primary-button",
                disabled: () => getBitcoinStatus() === "NON INIZIALIZZATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleBitcoinLogin();
                  return false;
                },
                type: "button",
              },
              "Sign In"
            ),
            h(
              "button",
              {
                class: "action-button",
                disabled: () => getBitcoinStatus() === "NON INIZIALIZZATO",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleBitcoinSignup();
                  return false;
                },
                type: "button",
              },
              "Register"
            )
          )
        );
      }

      function RelayManagementSection() {
        return h(
          "div",
          { class: "action-group fade-in" },
          h("h2", {}, "üåê Relay Management"),
          h("p", {}, "Manage Gun.js relay peers for decentralized networking"),

          // Current Peers Status Card
          h(
            "div",
            { class: "relay-status-card" },
            h(
              "div",
              { class: "relay-status-header" },
              h("h4", {}, "üîó Current Peers Status"),
              h(
                "span",
                {
                  class: "peer-count-badge",
                  style: () => {
                    const count = getPeerCount();
                    return count === 0
                      ? "background: var(--error-color);"
                      : "background: var(--success-color);";
                  },
                },
                () => getPeerCount().toString()
              )
            ),
            h("div", { class: "current-peers-display" }, () => {
              const peersList = getPeersList();
              if (
                peersList === "No peers configured" ||
                peersList === "Shogun not initialized" ||
                peersList === "Error loading peers"
              ) {
                return h(
                  "div",
                  { class: "no-peers-message" },
                  peersList === "Shogun not initialized"
                    ? "‚ö†Ô∏è Shogun not initialized"
                    : peersList === "Error loading peers"
                    ? "‚ùå Error loading peers"
                    : "üì° No peers configured yet"
                );
              } else {
                return h("div", {
                  class: "peers-list",
                  innerHTML: peersList,
                });
              }
            })
          ),

          // Add New Peer Section
          h(
            "div",
            { class: "add-peer-section" },
            h("h4", {}, "‚ûï Add New Relay"),
            h(
              "div",
              { class: "form-group" },
              h("input", {
                type: "url",
                placeholder:
                  "Enter relay URL (e.g., http://localhost:8000/gun)",
                value: () => getNewPeerUrl(),
                oninput: (e) => setNewPeerUrl(e.target.value),
              })
            ),

            h(
              "div",
              { class: "relay-examples" },
              h(
                "details",
                { class: "relay-examples-details" },
                h("summary", {}, "üìã Common relay examples"),
                h(
                  "div",
                  { class: "relay-examples-content" },
                  h(
                    "div",
                    {
                      class: "shogun-relay",
                      onclick: () =>
                        fillPeerUrl(
                          "https://ruling-mastodon-improved.ngrok-free.app/gun"
                        ),
                    },
                    h("code", {}, "ruling-mastodon-improved"),
                    h("span", { class: "example-label" }, "Shogun Relay")
                  ),
                  h(
                    "div",
                    {
                      class: "relay-example",
                      onclick: () =>
                        fillPeerUrl("https://gun-manhattan.herokuapp.com/gun"),
                    },
                    h("code", {}, "gun-manhattan.herokuapp"),
                    h("span", { class: "example-label" }, "Public relay")
                  ),
                  h(
                    "div",
                    {
                      class: "relay-example",
                      onclick: () => fillPeerUrl("https://peer.wallie.io/gun"),
                    },
                    h("code", {}, "peer.wallie"),
                    h("span", { class: "example-label" }, "Public relay")
                  )
                )
              )
            )
          ),

          // Action Buttons
          h(
            "div",
            { class: "form-actions" },
            h(
              "button",
              {
                class: "primary-button",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleAddPeer();
                  return false;
                },
                type: "button",
              },
              "‚ûï Add Peer"
            ),
            h(
              "button",
              {
                class: "action-button",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleRefreshPeers();
                  return false;
                },
                type: "button",
              },
              "üîÑ Refresh"
            ),
            h(
              "button",
              {
                class: "action-button warning-button",
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleClearAllPeers();
                  return false;
                },
                type: "button",
              },
              "üóëÔ∏è Clear All"
            )
          )
        );
      }

      function ResultsSection() {
        return h(
          "div",
          { class: "action-group fade-in", style: "grid-column: 1 / -1;" },
          h("h2", {}, "üìä Results"),
          h("div", { id: "results" }, () => getResults())
        );
      }

      function App() {
        return h(
          "div",
          { class: "container" },
          AppHeader(),
          h(
            "div",
            { class: "main-grid" },
            InitializationSection(),
            TraditionalAuthSection(),
            WebAuthnSection(),
            EthereumSection(),
            BitcoinSection(),
            RelayManagementSection(),
            ResultsSection()
          )
        );
      }

      handleInitialize();

      // Initialize the app
      document.addEventListener("DOMContentLoaded", () => {
        const appElement = App();
        document.getElementById("app").appendChild(appElement);

        // Show welcome message
        setTimeout(() => {
          showResult("Benvenuto", {
            message: "ü•∑ Benvenuto in Shogun Auth - NoDom Edition!",
            instructions: "Clicca su 'Initialize Shogun' per iniziare",
            features: [
              "üîê Autenticazione tradizionale",
              "üîë WebAuthn biometrico",
              "ü¶ä Wallet Ethereum",
              "‚Çø Wallet Bitcoin",
              "‚ö° Reattivit√† con NoDom",
            ],
            timestamp: new Date().toISOString(),
          });
        }, 500);
      });
    </script>
  </body>
</html>
